<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.21.0: Backtrace</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.21.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__m__backtrace__trace.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Backtrace<div class="ingroups"><a class="el" href="group__m__backtrace.html">Backtrace</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structM__backtrace__callbacks"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#structM__backtrace__callbacks">M_backtrace_callbacks</a></td></tr>
<tr class="separator:structM__backtrace__callbacks"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0be921ee7dd5a6e1fdd1c8b00cbec354"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga0be921ee7dd5a6e1fdd1c8b00cbec354">M_backtrace_filename_func</a>) (char *fname, size_t fname_len)</td></tr>
<tr class="separator:ga0be921ee7dd5a6e1fdd1c8b00cbec354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773d0187e55979ced51165388c4292cf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga773d0187e55979ced51165388c4292cf">M_backtrace_trace_data_func</a>) (const unsigned char *data, size_t len)</td></tr>
<tr class="separator:ga773d0187e55979ced51165388c4292cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601e7312f8e13eaea9ae478254c947fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga601e7312f8e13eaea9ae478254c947fa">M_backtrace_log_emergency_func</a>) (int sig, const char *message)</td></tr>
<tr class="separator:ga601e7312f8e13eaea9ae478254c947fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50760e61b8691f993e45d63f4eff5a8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#gae50760e61b8691f993e45d63f4eff5a8">M_backtrace_got_nonfatal_func</a>) (int sig)</td></tr>
<tr class="separator:gae50760e61b8691f993e45d63f4eff5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fc2eb42bf9c786544c095bbf690c7d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#gaa9fc2eb42bf9c786544c095bbf690c7d">M_backtrace_got_fatal_func</a>) (int sig)</td></tr>
<tr class="separator:gaa9fc2eb42bf9c786544c095bbf690c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga39f7f77ec463c24ed641319dd582124b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga39f7f77ec463c24ed641319dd582124b">M_backtrace_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga39f7f77ec463c24ed641319dd582124ba8e5f7eb975d4aaf54a5354e547789fc1">M_BACKTRACE_TYPE_BACKTRACE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga39f7f77ec463c24ed641319dd582124ba8c86a099a7bb5dad4badb5bcbc079c23">M_BACKTRACE_TYPE_DUMP</a>
<br />
 }</td></tr>
<tr class="separator:ga39f7f77ec463c24ed641319dd582124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746e9db320b8cb6642e05583eecd3e0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga746e9db320b8cb6642e05583eecd3e0a">M_backtrace_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga746e9db320b8cb6642e05583eecd3e0aa1fff1c97cd104e3cbf795ac282b2ea01">M_BACKTRACE_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga746e9db320b8cb6642e05583eecd3e0aae208e79138e3860c972276716a2acb2a">M_BACKTRACE_WRITE_FILE</a> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga746e9db320b8cb6642e05583eecd3e0aaa26a1a11d361776f772301fac7c8f08e">M_BACKTRACE_EXTENDED_DUMP</a> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="group__m__backtrace__trace.html#gga746e9db320b8cb6642e05583eecd3e0aaade46f05d0be19ddade8c908289c339c">M_BACKTRACE_CAPTURE_NONCRASH</a> = 1 &lt;&lt; 2
<br />
 }</td></tr>
<tr class="separator:ga746e9db320b8cb6642e05583eecd3e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga116c332e1374b234bc73881786b033e2"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga116c332e1374b234bc73881786b033e2">M_backtrace_enable</a> (<a class="el" href="group__m__backtrace__trace.html#ga39f7f77ec463c24ed641319dd582124b">M_backtrace_type_t</a> type, struct <a class="el" href="group__m__backtrace__trace.html#structM__backtrace__callbacks">M_backtrace_callbacks</a> *cbs, M_uint32 flags)</td></tr>
<tr class="separator:ga116c332e1374b234bc73881786b033e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18620e6884ceb71561b8e65cfad4f339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga18620e6884ceb71561b8e65cfad4f339">M_backtrace_set_ignore_signal</a> (int sig)</td></tr>
<tr class="separator:ga18620e6884ceb71561b8e65cfad4f339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f53f74fecccff6b84332880daa37d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#gab3f53f74fecccff6b84332880daa37d9">M_backtrace_set_nonfatal_signal</a> (int sig)</td></tr>
<tr class="separator:gab3f53f74fecccff6b84332880daa37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2880f7b4bab963304adbb959ee6fbf01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#ga2880f7b4bab963304adbb959ee6fbf01">M_backtrace_set_fatal_signal</a> (int sig)</td></tr>
<tr class="separator:ga2880f7b4bab963304adbb959ee6fbf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31045211e91a23de3add3a01187d87a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__backtrace__trace.html#gac31045211e91a23de3add3a01187d87a">M_backtrace_signal_use_default_handler</a> (int sig)</td></tr>
<tr class="separator:gac31045211e91a23de3add3a01187d87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Generates a back trace when certain signal are singled. This is primarily used for capturing information about a crash.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Use</h1>
<p>Backtrace data can either be written directly to a file or passed to a configured callback but not both. When writing to a file the M_backtrace_filename_func callback is required to be implemented. When capturing trace data, the M_backtrace_trace_data_func is required to be implemented. All other callbacks are optional.</p>
<p>Windows has the ability to generate backtrace as well as a mini dump file. Minidump requires writing directly to a file.</p>
<p>Other OS cannot use dump output and only support backtrace output.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Events</h1>
<p>There are three types of events:</p><ul>
<li>Fatal - Generate backtrace and exit the application.</li>
<li>Non-Fatal - Informational events that allow application to take an action.</li>
<li>Ignored - Events that are silenced and ignored.</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
Windows</h2>
<p>Only fatal events are supported on Windows.</p>
<p>Crash events are any events captured by SetUnhandledExceptionFilter.</p>
<p>Primary events (other could trigger):</p><ul>
<li>EXCEPTION_ACCESS_VIOLATION</li>
<li>EXCEPTION_ARRAY_BOUNDS_EXCEEDED</li>
<li>EXCEPTION_BREAKPOINT</li>
<li>EXCEPTION_DATATYPE_MISALIGNMENT</li>
<li>EXCEPTION_FLT_DENORMAL_OPERAND</li>
<li>EXCEPTION_FLT_DIVIDE_BY_ZERO</li>
<li>EXCEPTION_FLT_INEXACT_RESULT</li>
<li>EXCEPTION_FLT_INVALID_OPERATION</li>
<li>EXCEPTION_FLT_OVERFLOW</li>
<li>EXCEPTION_FLT_STACK_CHECK</li>
<li>EXCEPTION_FLT_UNDERFLOW</li>
<li>EXCEPTION_ILLEGAL_INSTRUCTION</li>
<li>EXCEPTION_IN_PAGE_ERROR</li>
<li>EXCEPTION_INT_DIVIDE_BY_ZERO</li>
<li>EXCEPTION_INT_OVERFLOW</li>
<li>EXCEPTION_INVALID_DISPOSITION</li>
<li>EXCEPTION_NONCONTINUABLE_EXCEPTION</li>
<li>EXCEPTION_PRIV_INSTRUCTION</li>
<li>EXCEPTION_SINGLE_STEP</li>
<li>EXCEPTION_STACK_OVERFLOW</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
Other OS</h2>
<p>Events are signals from singled.h.</p>
<dl class="section note"><dt>Note</dt><dd>Signals are global and their signal handler can be changed outside of this library. A backtrace will not be generated if the signal handler is changed.</dd></dl>
<p>Fatal signals (default captured):</p><ul>
<li>SIGPIPE</li>
<li>SIGSEGV</li>
<li>SIGBUS</li>
<li>SIGILL</li>
<li>SIGFPE</li>
</ul>
<p>Non-fatal signals (default captured):</p><ul>
<li>SIGINT</li>
<li>SIGQUIT</li>
<li>SIGTERM</li>
<li>SIGXFSZ</li>
</ul>
<p>Ignored signals (default captured):</p><ul>
<li>SIGCHLD</li>
<li>SIGUSR1</li>
<li>SIGUSR2</li>
</ul>
<p>Fatal signals are always enabled. Non-fatal and ignore will only be set during setup when the M_BACKTRACE_CAPTURE_NONCRASH flag is set. When not set only the default fatal signals are set to be captured.</p>
<p>Signals can be changed from one type to another and additional signals can be added to a given type using the M_backtrace_set_* functions. For example, some applications may want to treat SIGPIPE as non-fatal or ignore it altogether.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Platform notes</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
macOS</h2>
<p>macOS will not return filename or line numbers. This is a limitation of the OS. Additional tools need to be used to evaluate the trace data. Given this trace data. </p><pre class="fragment">0   libsystem_platform.dylib            0x00007fff70c3bf5a _sigtramp + 26
1   APP_NAME                            0x0000000101bc37af my_read + 95
2   APP_NAME                            0x0000000101bff381 mm_listen_connection + 545
</pre><p> lldb can be used to get the source file and line from the function and offset. </p><pre class="fragment">(lldb) so l -a my_read+95
</pre><p> The trace may not show the exact line that caused the crash but only the generate area where it occurred. For example, my_read+95 may point to line within my_read where function my_crashing_function is called. The crash may be somewhere within my_crashing_function.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Windows</h2>
<p>Example trace data when PDB is distributed with application (not typical outside of development): </p><pre class="fragment">EXCEPTION_ACCESS_VIOLATION at address 0x7ff614eb5e4a Invalid operation: write at address 0x00000000
0 - C:\Program Files\MY_APP\lib\mylib.dll + 21024 my_dt() at \cygdrive\c\build\my_file.c line 692
1 - C:\Program Files\MY_APP\lib\mylib.dll + 4202 my_do_thing() at \cygdrive\c\build\my_file.c line 1180
2 - C:\Program Files\MY_APP\lib\mylib.dll + 45 my_start() at \cygdrive\c\build\main.c line 316
</pre><p> Example trace data when PDB is <em>NOT</em> distributed with application (typical production deployment): </p><pre class="fragment">EXCEPTION_ACCESS_VIOLATION at address 0x7ff614eb5e4a Invalid operation: write at address 0x00000000
0 - C:\Program Files\MY_APP\app.exe + 292671
0 - C:\Program Files\MY_APP\app.exe + 286282
</pre><p> We have experienced the function name in the output being incorrect while the filename and line point to the correct location. For example my_dt() may not be correct and my_file.c line 692 is actually my_check_valid_dt. This is due to compiler optimizations such as inlining.</p>
<p>The location of '+ #' is the offset from the module base address. When using a PDB file for debugging you must get the base address from the debugger and add the offset to find the faulting address. PDB files use a virtual address that does not correspond to the address within the binary. Hence, an offset from the base address is provided by the backtrace.</p>
<p>If using Mingw PDB files can be generated by building with debug symbols, running cv2pdb, then stripping the binary.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Using Visual Studio to Lookup Addresses</h3>
<p>Lookup by address is important when the application is not distributed withe PDB files. Which is typical for pretty much every application. When this is the case the backtrace will only list modules and offsets. It will not include file names or line numbers. Instead we need to look this up using the module and offset within the module recorded in the backtrace.</p>
<ol type="1">
<li>Open Visual Studio</li>
<li>Choose File -&gt; Open -&gt; Project/Solution</li>
<li>Choose the exe (app.exe in above example). This will create a temporary/pseudo project to work in.</li>
<li>Choose Debug -&gt; Options</li>
<li>Go to Debugging -&gt; Symbols</li>
<li>Add the location of the PDB files</li>
<li>Right click the solution in the solution explorer and choose Properties</li>
<li>Go to Common Properties -&gt; Debug Source Files</li>
<li>Add the location of the source files</li>
<li>Choose Debug -&gt; Step Into. This will start the debugger and break on main</li>
<li>Chose Debug -&gt; Windows -&gt; Modules</li>
<li>Find the entry for the application or DLL referenced in the backtrace you're interested in</li>
<li>The Address column will include the start and end addresses for the module. Get the start address</li>
<li>Add the offset to the start address for the entry in the backtrace you're interested in</li>
<li>Choose Debug -&gt; Windows -&gt; Disassembly</li>
<li>In the Address entry put in the address you've calculated using the start and offset</li>
<li>The code will be inline with the disassemtly</li>
<li>Right click on the line corresponding to the address and choose Go To Source</li>
</ol>
<p>You are now at the line captured in the backtrace. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structM__backtrace__callbacks" id="structM__backtrace__callbacks"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structM__backtrace__callbacks">&#9670;&nbsp;</a></span>M_backtrace_callbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct M_backtrace_callbacks</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Callbacks. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2c0652ef99994c45b769ef1b79969984"></a><a class="el" href="group__m__backtrace__trace.html#ga0be921ee7dd5a6e1fdd1c8b00cbec354">M_backtrace_filename_func</a></td>
<td class="fieldname">
get_filename</td>
<td class="fielddoc">
<p>Get a filename when writing to file is enabled. Cannot be NULL if writing to a file. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afa1c23970ed1b3b6c4bfd0bbc34bbda6"></a><a class="el" href="group__m__backtrace__trace.html#ga773d0187e55979ced51165388c4292cf">M_backtrace_trace_data_func</a></td>
<td class="fieldname">
trace_data</td>
<td class="fielddoc">
<p>Backtrace data. Cannot be NULL when not writing to a file. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aefe0b4de01a1d7f8e80d3c8da8cb763e"></a><a class="el" href="group__m__backtrace__trace.html#ga601e7312f8e13eaea9ae478254c947fa">M_backtrace_log_emergency_func</a></td>
<td class="fieldname">
log_emergency</td>
<td class="fielddoc">
<p>Emergency log function with information about a crash event. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a170230658d7cbe74c55269bf711695dc"></a><a class="el" href="group__m__backtrace__trace.html#gae50760e61b8691f993e45d63f4eff5a8">M_backtrace_got_nonfatal_func</a></td>
<td class="fieldname">
got_nonfatal</td>
<td class="fielddoc">
<p>Non fatal event captured. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a685f96ee85226fe5afe637f4d2fc4a37"></a><a class="el" href="group__m__backtrace__trace.html#gaa9fc2eb42bf9c786544c095bbf690c7d">M_backtrace_got_fatal_func</a></td>
<td class="fieldname">
got_fatal</td>
<td class="fielddoc">
<p>A fatal event occurred and the application is about to exit. Informational only to allow last logging. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0be921ee7dd5a6e1fdd1c8b00cbec354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be921ee7dd5a6e1fdd1c8b00cbec354">&#9670;&nbsp;</a></span>M_backtrace_filename_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_backtrace_filename_func) (char *fname, size_t fname_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to get file name to write data to.</p>
<p>If the filename cannot be opened or written to the data will be lost. There is no recovery in this instance so it is very important the location can be used. The file will be created if it does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>Buffer to store the filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fname_len</td><td>Length of buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga773d0187e55979ced51165388c4292cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga773d0187e55979ced51165388c4292cf">&#9670;&nbsp;</a></span>M_backtrace_trace_data_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_backtrace_trace_data_func) (const unsigned char *data, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to receive backtrace data.</p>
<p>This can be called multiple times. For example, every line describing the trace could call this function.</p>
<p>Memory allocation or any function that could generate a signal should not be used within this callback. If writing to a file, it should be flushed after every write to reduce the risk of data loss.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data describing the backtrace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga601e7312f8e13eaea9ae478254c947fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601e7312f8e13eaea9ae478254c947fa">&#9670;&nbsp;</a></span>M_backtrace_log_emergency_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_backtrace_log_emergency_func) (int sig, const char *message)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to receive information about a backtrace event.</p>
<p>Information about an event suitable for logging. This is general information such as "segfault detected" and does not contain backtrace information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal or exception that generated this event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae50760e61b8691f993e45d63f4eff5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae50760e61b8691f993e45d63f4eff5a8">&#9670;&nbsp;</a></span>M_backtrace_got_nonfatal_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_backtrace_got_nonfatal_func) (int sig)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to handle non-fatal events.</p>
<dl class="section note"><dt>Note</dt><dd>UNIX only.</dd></dl>
<p>Non-fatal events do not generate a backtrace and are informational so the receiver can take additional action. For example, capturing the CTRL+C event to write to a log before exiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal or exception that generated this event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9fc2eb42bf9c786544c095bbf690c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fc2eb42bf9c786544c095bbf690c7d">&#9670;&nbsp;</a></span>M_backtrace_got_fatal_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_backtrace_got_fatal_func) (int sig)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback to signal a fatal even occurred and the application will exit.</p>
<p>This will be called after all trace_data and log_emergency calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal or exception that generated this event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga39f7f77ec463c24ed641319dd582124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f7f77ec463c24ed641319dd582124b">&#9670;&nbsp;</a></span>M_backtrace_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__backtrace__trace.html#ga39f7f77ec463c24ed641319dd582124b">M_backtrace_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of backtrae that should be generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga39f7f77ec463c24ed641319dd582124ba8e5f7eb975d4aaf54a5354e547789fc1"></a>M_BACKTRACE_TYPE_BACKTRACE&#160;</td><td class="fielddoc"><p>Stack trace. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39f7f77ec463c24ed641319dd582124ba8c86a099a7bb5dad4badb5bcbc079c23"></a>M_BACKTRACE_TYPE_DUMP&#160;</td><td class="fielddoc"><p>Binary dump of trace data. Windows only and generates a minidump. On all other OS will be treated as BACKTRACE. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga746e9db320b8cb6642e05583eecd3e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga746e9db320b8cb6642e05583eecd3e0a">&#9670;&nbsp;</a></span>M_backtrace_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__backtrace__trace.html#ga746e9db320b8cb6642e05583eecd3e0a">M_backtrace_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling behavior. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga746e9db320b8cb6642e05583eecd3e0aa1fff1c97cd104e3cbf795ac282b2ea01"></a>M_BACKTRACE_NONE&#160;</td><td class="fielddoc"><p>Normal behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga746e9db320b8cb6642e05583eecd3e0aae208e79138e3860c972276716a2acb2a"></a>M_BACKTRACE_WRITE_FILE&#160;</td><td class="fielddoc"><p>Write data to a file using the get_filename callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga746e9db320b8cb6642e05583eecd3e0aaa26a1a11d361776f772301fac7c8f08e"></a>M_BACKTRACE_EXTENDED_DUMP&#160;</td><td class="fielddoc"><p>When using dump type capture additional information about the event. This will produce a much larger dump file and can capture sensitive data in memory. For example, encryption keys. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga746e9db320b8cb6642e05583eecd3e0aaade46f05d0be19ddade8c908289c339c"></a>M_BACKTRACE_CAPTURE_NONCRASH&#160;</td><td class="fielddoc"><p>Setup default non-fatal and ignore signal handling on non-Windows OS. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga116c332e1374b234bc73881786b033e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga116c332e1374b234bc73881786b033e2">&#9670;&nbsp;</a></span>M_backtrace_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_backtrace_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__backtrace__trace.html#ga39f7f77ec463c24ed641319dd582124b">M_backtrace_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__m__backtrace__trace.html#structM__backtrace__callbacks">M_backtrace_callbacks</a> *&#160;</td>
          <td class="paramname"><em>cbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable backtracing in the application.</p>
<p>Cannot be called multiple times and cannot be disabled. Once enabled it is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of tracing that should happen. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbs</td><td>Callbacks to handle events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>M_backtrace_flags_t Flags controlling behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18620e6884ceb71561b8e65cfad4f339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18620e6884ceb71561b8e65cfad4f339">&#9670;&nbsp;</a></span>M_backtrace_set_ignore_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_backtrace_set_ignore_signal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ignore the signal.</p>
<p>This does <em>not</em> set SIG_IGN. Instead it sets a no-op function as the handler. If SIG_IGN is required it must be set using <code>signal(sig, SIG_IGN)</code> directly.</p>
<p>A no-op is used because of how SIG_IGN interacts with child processes. Per POSIX.1-2001, wait/waitpid will return ECHILD if SIGCHLD is set to SIG_IGN. If that's the case then children may not become zombies and wait/waitpid will block until all children have exited and fail with ECHILD. If using WNOHANG you'll get ECHILD immediately instead of being informed the child has exited.</p>
<dl class="section note"><dt>Note</dt><dd>Unix only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3f53f74fecccff6b84332880daa37d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f53f74fecccff6b84332880daa37d9">&#9670;&nbsp;</a></span>M_backtrace_set_nonfatal_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_backtrace_set_nonfatal_signal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consider the siginal as non-fatal</p>
<p>Will call the M_backtrace_got_fatal_func callback. If the callback not set the signal will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Unix only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2880f7b4bab963304adbb959ee6fbf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2880f7b4bab963304adbb959ee6fbf01">&#9670;&nbsp;</a></span>M_backtrace_set_fatal_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_backtrace_set_fatal_signal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consider the signal fatal.</p>
<dl class="section note"><dt>Note</dt><dd>Unix only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac31045211e91a23de3add3a01187d87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31045211e91a23de3add3a01187d87a">&#9670;&nbsp;</a></span>M_backtrace_signal_use_default_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_backtrace_signal_use_default_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the default sign handler.</p>
<p>Default is what is set by SIG_DFL</p>
<dl class="section note"><dt>Note</dt><dd>Unix only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 30 2022 16:23:55 for Mstdlib-1.21.0 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
