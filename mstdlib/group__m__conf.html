<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.18.0: CONF</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.18.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__m__conf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CONF<div class="ingroups"><a class="el" href="group__m__formats.html">Data Formats</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaac290bc7c633860d3490e40253c071d6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a></td></tr>
<tr class="separator:gaac290bc7c633860d3490e40253c071d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f0905524fb28cf2e6333f9ade45497"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga43f0905524fb28cf2e6333f9ade45497">M_conf_logger_t</a>) (const char *path, const char *msg)</td></tr>
<tr class="separator:ga43f0905524fb28cf2e6333f9ade45497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aaf2ce073cfabc0f1a29ef59910291c"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga8aaf2ce073cfabc0f1a29ef59910291c">M_conf_converter_buf_t</a>) (char *buf, size_t buf_len, const char *value, const char *default_val)</td></tr>
<tr class="separator:ga8aaf2ce073cfabc0f1a29ef59910291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10ab3307d18e462d7b9281cd2aa0e96"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gaf10ab3307d18e462d7b9281cd2aa0e96">M_conf_converter_strdup_t</a>) (char **mem, const char *value, const char *default_val)</td></tr>
<tr class="separator:gaf10ab3307d18e462d7b9281cd2aa0e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abfe9d879ab797ee435b6792e3cdbdd"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga5abfe9d879ab797ee435b6792e3cdbdd">M_conf_converter_int8_t</a>) (M_int8 *mem, const char *value, M_int8 default_val)</td></tr>
<tr class="separator:ga5abfe9d879ab797ee435b6792e3cdbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bb6781a51c1f461fd60e76bf66ab05"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gae7bb6781a51c1f461fd60e76bf66ab05">M_conf_converter_int16_t</a>) (M_int16 *mem, const char *value, M_int16 default_val)</td></tr>
<tr class="separator:gae7bb6781a51c1f461fd60e76bf66ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ddc88da9bdb5b59578557275b3aff6"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga29ddc88da9bdb5b59578557275b3aff6">M_conf_converter_int32_t</a>) (M_int32 *mem, const char *value, M_int32 default_val)</td></tr>
<tr class="separator:ga29ddc88da9bdb5b59578557275b3aff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafacab63cc6af22efe6689d5654f609f2"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gafacab63cc6af22efe6689d5654f609f2">M_conf_converter_int64_t</a>) (M_int64 *mem, const char *value, M_int64 default_val)</td></tr>
<tr class="separator:gafacab63cc6af22efe6689d5654f609f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1039216960ecc6d73dd46506673c881"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gaf1039216960ecc6d73dd46506673c881">M_conf_converter_uint8_t</a>) (M_uint8 *mem, const char *value, M_uint8 default_val)</td></tr>
<tr class="separator:gaf1039216960ecc6d73dd46506673c881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1423b3fdb407a13b73cead9c6ba472b9"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga1423b3fdb407a13b73cead9c6ba472b9">M_conf_converter_uint16_t</a>) (M_uint16 *mem, const char *value, M_uint16 default_val)</td></tr>
<tr class="separator:ga1423b3fdb407a13b73cead9c6ba472b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb85624cc442513413775db1517b2b07"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gadb85624cc442513413775db1517b2b07">M_conf_converter_uint32_t</a>) (M_uint32 *mem, const char *value, M_uint32 default_val)</td></tr>
<tr class="separator:gadb85624cc442513413775db1517b2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b162c6e0030211040b009240f8d674a"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga1b162c6e0030211040b009240f8d674a">M_conf_converter_uint64_t</a>) (M_uint64 *mem, const char *value, M_uint64 default_val)</td></tr>
<tr class="separator:ga1b162c6e0030211040b009240f8d674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bf8f8a26d939795d1e9067187e31f7"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga02bf8f8a26d939795d1e9067187e31f7">M_conf_converter_sizet_t</a>) (size_t *mem, const char *value, size_t default_val)</td></tr>
<tr class="separator:ga02bf8f8a26d939795d1e9067187e31f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56af410e1358e4dff55166cef25b4488"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga56af410e1358e4dff55166cef25b4488">M_conf_converter_bool_t</a>) (M_bool *mem, const char *value, M_bool default_val)</td></tr>
<tr class="separator:ga56af410e1358e4dff55166cef25b4488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ccc6447638ce8b3ba955879ef630b8"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga64ccc6447638ce8b3ba955879ef630b8">M_conf_converter_custom_t</a>) (void *mem, const char *value)</td></tr>
<tr class="separator:ga64ccc6447638ce8b3ba955879ef630b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646da551f1482e6c8a3630409d88d593"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga646da551f1482e6c8a3630409d88d593">M_conf_validator_t</a>) (void *data)</td></tr>
<tr class="separator:ga646da551f1482e6c8a3630409d88d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga116f6b479e95994dd41b52af07698917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga116f6b479e95994dd41b52af07698917">M_conf_create</a> (const char *path, M_bool allow_multiple, char *errbuf, size_t errbuf_len)</td></tr>
<tr class="separator:ga116f6b479e95994dd41b52af07698917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b70c85a462a9f31b3c1754b2c493e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga5b70c85a462a9f31b3c1754b2c493e14">M_conf_destroy</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf)</td></tr>
<tr class="separator:ga5b70c85a462a9f31b3c1754b2c493e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00210df332cc12836314d7bff4f707d"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gab00210df332cc12836314d7bff4f707d">M_conf_add_debug_logger</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, <a class="el" href="group__m__conf.html#ga43f0905524fb28cf2e6333f9ade45497">M_conf_logger_t</a> debug_logger)</td></tr>
<tr class="separator:gab00210df332cc12836314d7bff4f707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7954ebaebeae1928a6890b44add60646"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga7954ebaebeae1928a6890b44add60646">M_conf_add_error_logger</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, <a class="el" href="group__m__conf.html#ga43f0905524fb28cf2e6333f9ade45497">M_conf_logger_t</a> error_logger)</td></tr>
<tr class="separator:ga7954ebaebeae1928a6890b44add60646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0faef10ccb592c627b1bca42207dbe63"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf)</td></tr>
<tr class="separator:ga0faef10ccb592c627b1bca42207dbe63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb0ae03f80bed9808cb2a9cbb55a3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga4eb0ae03f80bed9808cb2a9cbb55a3bc">M_conf_unused_keys</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf)</td></tr>
<tr class="separator:ga4eb0ae03f80bed9808cb2a9cbb55a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b829c53e35427a848218f0e6299a7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga0b829c53e35427a848218f0e6299a7b8">M_conf_get_sections</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf)</td></tr>
<tr class="separator:ga0b829c53e35427a848218f0e6299a7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814d49e7dbc25454640c074022158f09"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga814d49e7dbc25454640c074022158f09">M_conf_get_value</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key)</td></tr>
<tr class="separator:ga814d49e7dbc25454640c074022158f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f24ddb7acc5bee3b085dfb24059867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gaf6f24ddb7acc5bee3b085dfb24059867">M_conf_get_values</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key)</td></tr>
<tr class="separator:gaf6f24ddb7acc5bee3b085dfb24059867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cd07cbbd816c34115ca81d12f7de1c9"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga6cd07cbbd816c34115ca81d12f7de1c9">M_conf_register_buf</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, char *buf, size_t buf_len, const char *default_val, const char *regex, <a class="el" href="group__m__conf.html#ga8aaf2ce073cfabc0f1a29ef59910291c">M_conf_converter_buf_t</a> converter)</td></tr>
<tr class="separator:ga6cd07cbbd816c34115ca81d12f7de1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89b6e9542fc4235b18195ebaec9ceed"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gaa89b6e9542fc4235b18195ebaec9ceed">M_conf_register_strdup</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, char **address, const char *default_val, const char *regex, <a class="el" href="group__m__conf.html#gaf10ab3307d18e462d7b9281cd2aa0e96">M_conf_converter_strdup_t</a> converter)</td></tr>
<tr class="separator:gaa89b6e9542fc4235b18195ebaec9ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccb09046cfa4d67fb964f5e3059ae46"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gadccb09046cfa4d67fb964f5e3059ae46">M_conf_register_int8</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_int8 *mem, M_int8 default_val, M_int8 min_val, M_int8 max_val, <a class="el" href="group__m__conf.html#ga5abfe9d879ab797ee435b6792e3cdbdd">M_conf_converter_int8_t</a> converter)</td></tr>
<tr class="separator:gadccb09046cfa4d67fb964f5e3059ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc652c7aebc38f30dcf2e5863bd19a1"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gadcc652c7aebc38f30dcf2e5863bd19a1">M_conf_register_int16</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_int16 *mem, M_int16 default_val, M_int16 min_val, M_int16 max_val, <a class="el" href="group__m__conf.html#gae7bb6781a51c1f461fd60e76bf66ab05">M_conf_converter_int16_t</a> converter)</td></tr>
<tr class="separator:gadcc652c7aebc38f30dcf2e5863bd19a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2d49bd3dff578fb815c2b639d23575"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga0f2d49bd3dff578fb815c2b639d23575">M_conf_register_int32</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_int32 *mem, M_int32 default_val, M_int32 min_val, M_int32 max_val, <a class="el" href="group__m__conf.html#ga29ddc88da9bdb5b59578557275b3aff6">M_conf_converter_int32_t</a> converter)</td></tr>
<tr class="separator:ga0f2d49bd3dff578fb815c2b639d23575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c61e4fbd9c21738531ff2abb8c3fba3"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga9c61e4fbd9c21738531ff2abb8c3fba3">M_conf_register_int64</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_int64 *mem, M_int64 default_val, M_int64 min_val, M_int64 max_val, <a class="el" href="group__m__conf.html#gafacab63cc6af22efe6689d5654f609f2">M_conf_converter_int64_t</a> converter)</td></tr>
<tr class="separator:ga9c61e4fbd9c21738531ff2abb8c3fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3b1f30ee320c029bf9a33aa9c18087"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga1f3b1f30ee320c029bf9a33aa9c18087">M_conf_register_uint8</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_uint8 *mem, M_uint8 default_val, M_uint8 min_val, M_uint8 max_val, <a class="el" href="group__m__conf.html#gaf1039216960ecc6d73dd46506673c881">M_conf_converter_uint8_t</a> converter)</td></tr>
<tr class="separator:ga1f3b1f30ee320c029bf9a33aa9c18087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac103c0f9c851a2910ded2b38ecb09c93"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gac103c0f9c851a2910ded2b38ecb09c93">M_conf_register_uint16</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_uint16 *mem, M_uint16 default_val, M_uint16 min_val, M_uint16 max_val, <a class="el" href="group__m__conf.html#ga1423b3fdb407a13b73cead9c6ba472b9">M_conf_converter_uint16_t</a> converter)</td></tr>
<tr class="separator:gac103c0f9c851a2910ded2b38ecb09c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bac8cf215e7d36d30778d1779da445"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga87bac8cf215e7d36d30778d1779da445">M_conf_register_uint32</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_uint32 *mem, M_uint32 default_val, M_uint32 min_val, M_uint32 max_val, <a class="el" href="group__m__conf.html#gadb85624cc442513413775db1517b2b07">M_conf_converter_uint32_t</a> converter)</td></tr>
<tr class="separator:ga87bac8cf215e7d36d30778d1779da445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae686e07d650501b0c758a5d122255741"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gae686e07d650501b0c758a5d122255741">M_conf_register_uint64</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_uint64 *mem, M_uint64 default_val, M_uint64 min_val, M_uint64 max_val, <a class="el" href="group__m__conf.html#ga1b162c6e0030211040b009240f8d674a">M_conf_converter_uint64_t</a> converter)</td></tr>
<tr class="separator:gae686e07d650501b0c758a5d122255741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5caba7a59d2b7659c1d9b048ab286a0"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gac5caba7a59d2b7659c1d9b048ab286a0">M_conf_register_sizet</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, size_t *mem, size_t default_val, size_t min_val, size_t max_val, <a class="el" href="group__m__conf.html#ga02bf8f8a26d939795d1e9067187e31f7">M_conf_converter_sizet_t</a> converter)</td></tr>
<tr class="separator:gac5caba7a59d2b7659c1d9b048ab286a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82b6b62dfff857de71d6ccee41bea90"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#gab82b6b62dfff857de71d6ccee41bea90">M_conf_register_bool</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, M_bool *mem, M_bool default_val, <a class="el" href="group__m__conf.html#ga56af410e1358e4dff55166cef25b4488">M_conf_converter_bool_t</a> converter)</td></tr>
<tr class="separator:gab82b6b62dfff857de71d6ccee41bea90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455b51d65b197be16cf9913eee3531fb"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga455b51d65b197be16cf9913eee3531fb">M_conf_register_custom</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, const char *key, void *mem, <a class="el" href="group__m__conf.html#ga64ccc6447638ce8b3ba955879ef630b8">M_conf_converter_custom_t</a> converter)</td></tr>
<tr class="separator:ga455b51d65b197be16cf9913eee3531fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5539dfa70f44ee372f26799d1c33ab93"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__conf.html#ga5539dfa70f44ee372f26799d1c33ab93">M_conf_register_validator</a> (<a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf, <a class="el" href="group__m__conf.html#ga646da551f1482e6c8a3630409d88d593">M_conf_validator_t</a> validator, void *data)</td></tr>
<tr class="separator:ga5539dfa70f44ee372f26799d1c33ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Wrapper around mstdlib's INI module for parsing configuration files and saving values. The file must be formatted as described in the INI module. This does not cover other file formats, such as JSON or XML.</p>
<p>This module is used for reading values from a configuration file directly into the provided memory. If you want to hold the values in temporary memory for manipulation and retrieval, you should use the Settings module.</p>
<p>You begin by building out all the key registrations, which specify the key to parse and where to store the value. There are multiple methods to handle the various data types that can be set. If you need to set a non-standardized data type like an enum or struct, you should use the custom registration method.</p>
<p>When building a key registration, you can also specify validators (depending on the data type) and a default value to use if a value isn't specified in the config file.</p>
<p>Every registration type has a corresponding conversion callback specific to it. If a callback is set with the registration, then that callback must do all the work of validating, converting, and storing the value.</p>
<p>Once all the registrations are set, you send the call to run through them all at once. We made the design decision to set everything up first and then parse the values over parsing on the fly as keys are registered so that all errors would be contained in one area. Instead of needing to do error checking for every registration, you only have to check the outcome of <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a>.</p>
<p>Alternatively, you can access a key's value directly without setting up a registration.</p>
<p>To received debug and/or error messages, you can register a callback that will be provided the message as well as the filename of the file currently being processed. This is optional.</p>
<p>Example:</p>
<div class="fragment"><div class="line">M_int8   num1;</div>
<div class="line">M_uint32 num2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> log_conf_debug(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;[DEBUG] %s: %s\n&quot;</span>, path, msg);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> log_conf_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;[ERROR] %s: %s\n&quot;</span>, path, msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> M_bool handle_num2(M_uint32 *mem, <span class="keyword">const</span> <span class="keywordtype">char</span> *value, M_uint32 default_val)</div>
<div class="line">{</div>
<div class="line">    M_int64 num;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__m__str__check.html#ga530dc6e198ebf9e5c30bc7a28ea4567d">M_str_isempty</a>(value)) {</div>
<div class="line">       *mem = default_val;</div>
<div class="line">       <span class="keywordflow">return</span> M_TRUE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    num = <a class="code" href="group__m__str__convert.html#ga1996be5d15c6f8a406e8c4782abf901a">M_str_to_int64</a>(value);</div>
<div class="line">    <span class="keywordflow">if</span> (num &lt; 0) {</div>
<div class="line">       *mem = 0;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num &gt; 64) {</div>
<div class="line">       *mem = 64;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">       *mem = num;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> M_TRUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> M_bool handle_flags(<span class="keywordtype">void</span> *mem, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)</div>
<div class="line">{</div>
<div class="line">    M_uint64   *flags = mem;</div>
<div class="line">    <span class="keywordtype">char</span>      **parts;</div>
<div class="line">    <span class="keywordtype">size_t</span>      num_parts;</div>
<div class="line">    <span class="keywordtype">size_t</span>      i;</div>
<div class="line"> </div>
<div class="line">    *flags = 0;</div>
<div class="line"> </div>
<div class="line">    parts = <a class="code" href="group__m__str__parse.html#gafa41a6a47d1c175509bac94decb52cbf">M_str_explode_str</a>(<span class="charliteral">&#39;|&#39;</span>, value, &amp;num_parts);</div>
<div class="line">    <span class="keywordflow">if</span> (parts == NULL)</div>
<div class="line">       <span class="keywordflow">return</span> M_FALSE;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (i=0; i&lt;num_parts; i++) {</div>
<div class="line">       *flags |= parse_flag(parts[i]);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="group__m__str__parse.html#ga6467a229b431287f958925e8eb8885eb">M_str_explode_free</a>(parts, num_parts);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> M_TRUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> M_bool validate_data(<span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> *name_buf = data;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a>(name_buf) &gt; 128) {</div>
<div class="line">       <span class="keywordflow">return</span> M_FALSE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (num2 &lt; num1) {</div>
<div class="line">     <span class="keywordflow">return</span> M_FALSE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> M_TRUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">M_bool parse_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *conf;</div>
<div class="line">    <span class="keywordtype">char</span>      err_buf[256];</div>
<div class="line">    <span class="keywordtype">char</span>      name_buf[256];</div>
<div class="line">    <span class="keywordtype">char</span>     *desc;</div>
<div class="line">    M_bool    active;</div>
<div class="line">    M_uint64  flags;</div>
<div class="line">    M_bool    ret;</div>
<div class="line"> </div>
<div class="line">    conf = <a class="code" href="group__m__conf.html#ga116f6b479e95994dd41b52af07698917">M_conf_create</a>(path, M_FALSE, err_buf, <span class="keyword">sizeof</span>(err_buf));</div>
<div class="line">    <span class="keywordflow">if</span> (conf == NULL) {</div>
<div class="line">       <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;Error reading conf: %s&quot;</span>, err_buf);</div>
<div class="line">       <span class="keywordflow">return</span> M_FALSE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__m__conf.html#gab00210df332cc12836314d7bff4f707d">M_conf_add_debug_logger</a>(conf, log_conf_debug);</div>
<div class="line">    <a class="code" href="group__m__conf.html#ga7954ebaebeae1928a6890b44add60646">M_conf_add_error_logger</a>(conf, log_conf_error);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__m__conf.html#ga6cd07cbbd816c34115ca81d12f7de1c9">M_conf_register_buf</a>(conf, <span class="stringliteral">&quot;name&quot;</span>, name_buf, <span class="keyword">sizeof</span>(name_buf), <span class="stringliteral">&quot;unknown&quot;</span>, <span class="stringliteral">&quot;^[a-zA-Z]$&quot;</span>, NULL);</div>
<div class="line">    <a class="code" href="group__m__conf.html#gaa89b6e9542fc4235b18195ebaec9ceed">M_conf_register_strdup</a>(conf, <span class="stringliteral">&quot;description&quot;</span>, &amp;desc, NULL, NULL, NULL);</div>
<div class="line">    <a class="code" href="group__m__conf.html#gadccb09046cfa4d67fb964f5e3059ae46">M_conf_register_int8</a>(conf, <span class="stringliteral">&quot;num1&quot;</span>, &amp;num1, 0, -10, 10, NULL);</div>
<div class="line">    <a class="code" href="group__m__conf.html#ga87bac8cf215e7d36d30778d1779da445">M_conf_register_uint32</a>(conf, <span class="stringliteral">&quot;num2&quot;</span>, &amp;num2, 16, 0, 0, handle_num2);</div>
<div class="line">    <a class="code" href="group__m__conf.html#gab82b6b62dfff857de71d6ccee41bea90">M_conf_register_bool</a>(conf, <span class="stringliteral">&quot;active&quot;</span>, &amp;active, M_FALSE, NULL);</div>
<div class="line">    <a class="code" href="group__m__conf.html#ga455b51d65b197be16cf9913eee3531fb">M_conf_register_custom</a>(conf, <span class="stringliteral">&quot;flags&quot;</span>, &amp;flags, handle_flags);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__m__conf.html#ga5539dfa70f44ee372f26799d1c33ab93">M_conf_register_validator</a>(conf, validate_data, name_buf);</div>
<div class="line"> </div>
<div class="line">    ret = <a class="code" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse</a>(conf);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__m__conf.html#ga5b70c85a462a9f31b3c1754b2c493e14">M_conf_destroy</a>(conf);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (ret) {</div>
<div class="line">       <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;Successfully parsed conf&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">       <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;Error parsing conf&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__m__conf_html_ga0faef10ccb592c627b1bca42207dbe63"><div class="ttname"><a href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse</a></div><div class="ttdeci">M_bool M_conf_parse(M_conf_t *conf)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga116f6b479e95994dd41b52af07698917"><div class="ttname"><a href="group__m__conf.html#ga116f6b479e95994dd41b52af07698917">M_conf_create</a></div><div class="ttdeci">M_conf_t * M_conf_create(const char *path, M_bool allow_multiple, char *errbuf, size_t errbuf_len)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga455b51d65b197be16cf9913eee3531fb"><div class="ttname"><a href="group__m__conf.html#ga455b51d65b197be16cf9913eee3531fb">M_conf_register_custom</a></div><div class="ttdeci">M_bool M_conf_register_custom(M_conf_t *conf, const char *key, void *mem, M_conf_converter_custom_t converter)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga5539dfa70f44ee372f26799d1c33ab93"><div class="ttname"><a href="group__m__conf.html#ga5539dfa70f44ee372f26799d1c33ab93">M_conf_register_validator</a></div><div class="ttdeci">M_bool M_conf_register_validator(M_conf_t *conf, M_conf_validator_t validator, void *data)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga5b70c85a462a9f31b3c1754b2c493e14"><div class="ttname"><a href="group__m__conf.html#ga5b70c85a462a9f31b3c1754b2c493e14">M_conf_destroy</a></div><div class="ttdeci">void M_conf_destroy(M_conf_t *conf)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga6cd07cbbd816c34115ca81d12f7de1c9"><div class="ttname"><a href="group__m__conf.html#ga6cd07cbbd816c34115ca81d12f7de1c9">M_conf_register_buf</a></div><div class="ttdeci">M_bool M_conf_register_buf(M_conf_t *conf, const char *key, char *buf, size_t buf_len, const char *default_val, const char *regex, M_conf_converter_buf_t converter)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga7954ebaebeae1928a6890b44add60646"><div class="ttname"><a href="group__m__conf.html#ga7954ebaebeae1928a6890b44add60646">M_conf_add_error_logger</a></div><div class="ttdeci">M_bool M_conf_add_error_logger(M_conf_t *conf, M_conf_logger_t error_logger)</div></div>
<div class="ttc" id="agroup__m__conf_html_ga87bac8cf215e7d36d30778d1779da445"><div class="ttname"><a href="group__m__conf.html#ga87bac8cf215e7d36d30778d1779da445">M_conf_register_uint32</a></div><div class="ttdeci">M_bool M_conf_register_uint32(M_conf_t *conf, const char *key, M_uint32 *mem, M_uint32 default_val, M_uint32 min_val, M_uint32 max_val, M_conf_converter_uint32_t converter)</div></div>
<div class="ttc" id="agroup__m__conf_html_gaa89b6e9542fc4235b18195ebaec9ceed"><div class="ttname"><a href="group__m__conf.html#gaa89b6e9542fc4235b18195ebaec9ceed">M_conf_register_strdup</a></div><div class="ttdeci">M_bool M_conf_register_strdup(M_conf_t *conf, const char *key, char **address, const char *default_val, const char *regex, M_conf_converter_strdup_t converter)</div></div>
<div class="ttc" id="agroup__m__conf_html_gaac290bc7c633860d3490e40253c071d6"><div class="ttname"><a href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a></div><div class="ttdeci">struct M_conf_t M_conf_t</div><div class="ttdef"><b>Definition:</b> m_conf.h:192</div></div>
<div class="ttc" id="agroup__m__conf_html_gab00210df332cc12836314d7bff4f707d"><div class="ttname"><a href="group__m__conf.html#gab00210df332cc12836314d7bff4f707d">M_conf_add_debug_logger</a></div><div class="ttdeci">M_bool M_conf_add_debug_logger(M_conf_t *conf, M_conf_logger_t debug_logger)</div></div>
<div class="ttc" id="agroup__m__conf_html_gab82b6b62dfff857de71d6ccee41bea90"><div class="ttname"><a href="group__m__conf.html#gab82b6b62dfff857de71d6ccee41bea90">M_conf_register_bool</a></div><div class="ttdeci">M_bool M_conf_register_bool(M_conf_t *conf, const char *key, M_bool *mem, M_bool default_val, M_conf_converter_bool_t converter)</div></div>
<div class="ttc" id="agroup__m__conf_html_gadccb09046cfa4d67fb964f5e3059ae46"><div class="ttname"><a href="group__m__conf.html#gadccb09046cfa4d67fb964f5e3059ae46">M_conf_register_int8</a></div><div class="ttdeci">M_bool M_conf_register_int8(M_conf_t *conf, const char *key, M_int8 *mem, M_int8 default_val, M_int8 min_val, M_int8 max_val, M_conf_converter_int8_t converter)</div></div>
<div class="ttc" id="agroup__m__fmt_html_gae54b252ea2bcf34b09ef1fa0f134ffa8"><div class="ttname"><a href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a></div><div class="ttdeci">ssize_t M_printf(const char *fmt,...)</div></div>
<div class="ttc" id="agroup__m__str__check_html_ga530dc6e198ebf9e5c30bc7a28ea4567d"><div class="ttname"><a href="group__m__str__check.html#ga530dc6e198ebf9e5c30bc7a28ea4567d">M_str_isempty</a></div><div class="ttdeci">M_bool M_str_isempty(const char *s) M_WARN_UNUSED_RESULT</div></div>
<div class="ttc" id="agroup__m__str__check_html_gabebfa875d1ada2b43f52b9344b0844d0"><div class="ttname"><a href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a></div><div class="ttdeci">size_t M_str_len(const char *s) M_WARN_UNUSED_RESULT</div></div>
<div class="ttc" id="agroup__m__str__convert_html_ga1996be5d15c6f8a406e8c4782abf901a"><div class="ttname"><a href="group__m__str__convert.html#ga1996be5d15c6f8a406e8c4782abf901a">M_str_to_int64</a></div><div class="ttdeci">M_int64 M_str_to_int64(const char *s) M_WARN_UNUSED_RESULT</div></div>
<div class="ttc" id="agroup__m__str__parse_html_ga6467a229b431287f958925e8eb8885eb"><div class="ttname"><a href="group__m__str__parse.html#ga6467a229b431287f958925e8eb8885eb">M_str_explode_free</a></div><div class="ttdeci">void M_str_explode_free(char **strs, size_t num) M_FREE(1)</div></div>
<div class="ttc" id="agroup__m__str__parse_html_gafa41a6a47d1c175509bac94decb52cbf"><div class="ttname"><a href="group__m__str__parse.html#gafa41a6a47d1c175509bac94decb52cbf">M_str_explode_str</a></div><div class="ttdeci">char ** M_str_explode_str(unsigned char delim, const char *s, size_t *num) M_WARN_UNUSED_RESULT M_MALLOC</div></div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="gaac290bc7c633860d3490e40253c071d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac290bc7c633860d3490e40253c071d6">&#9670;&nbsp;</a></span>M_conf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> <a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga43f0905524fb28cf2e6333f9ade45497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f0905524fb28cf2e6333f9ade45497">&#9670;&nbsp;</a></span>M_conf_logger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_conf_logger_t) (const char *path, const char *msg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for logging messages while parsing values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of configuration file being read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Message to log. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aaf2ce073cfabc0f1a29ef59910291c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aaf2ce073cfabc0f1a29ef59910291c">&#9670;&nbsp;</a></span>M_conf_converter_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_buf_t) (char *buf, size_t buf_len, const char *value, const char *default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-string conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer to store the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="gaf10ab3307d18e462d7b9281cd2aa0e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10ab3307d18e462d7b9281cd2aa0e96">&#9670;&nbsp;</a></span>M_conf_converter_strdup_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_strdup_t) (char **mem, const char *value, const char *default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-string conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. The caller is responsible for free'ing this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga5abfe9d879ab797ee435b6792e3cdbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5abfe9d879ab797ee435b6792e3cdbdd">&#9670;&nbsp;</a></span>M_conf_converter_int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_int8_t) (M_int8 *mem, const char *value, M_int8 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for signed 8-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="gae7bb6781a51c1f461fd60e76bf66ab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bb6781a51c1f461fd60e76bf66ab05">&#9670;&nbsp;</a></span>M_conf_converter_int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_int16_t) (M_int16 *mem, const char *value, M_int16 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for signed 16-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga29ddc88da9bdb5b59578557275b3aff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ddc88da9bdb5b59578557275b3aff6">&#9670;&nbsp;</a></span>M_conf_converter_int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_int32_t) (M_int32 *mem, const char *value, M_int32 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for signed 32-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="gafacab63cc6af22efe6689d5654f609f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafacab63cc6af22efe6689d5654f609f2">&#9670;&nbsp;</a></span>M_conf_converter_int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_int64_t) (M_int64 *mem, const char *value, M_int64 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for signed 64-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="gaf1039216960ecc6d73dd46506673c881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1039216960ecc6d73dd46506673c881">&#9670;&nbsp;</a></span>M_conf_converter_uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_uint8_t) (M_uint8 *mem, const char *value, M_uint8 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for unsigned 8-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga1423b3fdb407a13b73cead9c6ba472b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1423b3fdb407a13b73cead9c6ba472b9">&#9670;&nbsp;</a></span>M_conf_converter_uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_uint16_t) (M_uint16 *mem, const char *value, M_uint16 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for unsigned 16-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="gadb85624cc442513413775db1517b2b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb85624cc442513413775db1517b2b07">&#9670;&nbsp;</a></span>M_conf_converter_uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_uint32_t) (M_uint32 *mem, const char *value, M_uint32 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for unsigned 32-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga1b162c6e0030211040b009240f8d674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b162c6e0030211040b009240f8d674a">&#9670;&nbsp;</a></span>M_conf_converter_uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_uint64_t) (M_uint64 *mem, const char *value, M_uint64 default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for unsigned 64-bit integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga02bf8f8a26d939795d1e9067187e31f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bf8f8a26d939795d1e9067187e31f7">&#9670;&nbsp;</a></span>M_conf_converter_sizet_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_sizet_t) (size_t *mem, const char *value, size_t default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-integer conversions for size_t integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga56af410e1358e4dff55166cef25b4488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56af410e1358e4dff55166cef25b4488">&#9670;&nbsp;</a></span>M_conf_converter_bool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_bool_t) (M_bool *mem, const char *value, M_bool default_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for manual string-to-boolean conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>The default value as registered for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga64ccc6447638ce8b3ba955879ef630b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ccc6447638ce8b3ba955879ef630b8">&#9670;&nbsp;</a></span>M_conf_converter_custom_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_converter_custom_t) (void *mem, const char *value)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for custom conversions. This is used for manually validating and setting a value with <a class="el" href="group__m__conf.html#ga455b51d65b197be16cf9913eee3531fb">M_conf_register_custom()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>Memory address where the value should be stored. May be NULL if address was not registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value in the configuration file for the registered key. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the conversion was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<a id="ga646da551f1482e6c8a3630409d88d593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646da551f1482e6c8a3630409d88d593">&#9670;&nbsp;</a></span>M_conf_validator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_conf_validator_t) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for validating arbitrary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary data, as registered with the callback. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the validation was successful. Otherwise, M_FALSE. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga116f6b479e95994dd41b52af07698917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga116f6b479e95994dd41b52af07698917">&#9670;&nbsp;</a></span>M_conf_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a>* M_conf_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>allow_multiple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errbuf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new M_conf_t object with the specified ini.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_multiple</td><td>M_TRUE to allow a single key to have multiple values. Otherwise, M_FALSE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errbuf</td><td>Buffer to hold error message. Only populated if return is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errbuf_len</td><td>Size of buffer for holding error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated M_conf_t object, or NULL on error. </dd></dl>

</div>
</div>
<a id="ga5b70c85a462a9f31b3c1754b2c493e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b70c85a462a9f31b3c1754b2c493e14">&#9670;&nbsp;</a></span>M_conf_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_conf_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an M_conf_t object and free the memory.</p>
<p>Before destruction, all unused keys will be logged with the debug loggers (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab00210df332cc12836314d7bff4f707d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00210df332cc12836314d7bff4f707d">&#9670;&nbsp;</a></span>M_conf_add_debug_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_add_debug_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga43f0905524fb28cf2e6333f9ade45497">M_conf_logger_t</a>&#160;</td>
          <td class="paramname"><em>debug_logger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a debug logger to this conf object that will be passed various debug messages while parsing the values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to attach this logger to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_logger</td><td>The logging callback that will receive the error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7954ebaebeae1928a6890b44add60646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7954ebaebeae1928a6890b44add60646">&#9670;&nbsp;</a></span>M_conf_add_error_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_add_error_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga43f0905524fb28cf2e6333f9ade45497">M_conf_logger_t</a>&#160;</td>
          <td class="paramname"><em>error_logger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an error logger to this conf object that will be passed any errors that happen while parsing the values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to attach this logger to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_logger</td><td>The logging callback that will receive the error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0faef10ccb592c627b1bca42207dbe63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0faef10ccb592c627b1bca42207dbe63">&#9670;&nbsp;</a></span>M_conf_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Go through the key registrations and set the values at the specified locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registrations were processed successfully. Otherwise, M_FALSE. This fails if any of the registrations fail, like if a value does not pass the regex check or is outside of the min/max bounds. </dd></dl>

</div>
</div>
<a id="ga4eb0ae03f80bed9808cb2a9cbb55a3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb0ae03f80bed9808cb2a9cbb55a3bc">&#9670;&nbsp;</a></span>M_conf_unused_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a>* M_conf_unused_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a list of keys from the ini file that were not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of keys. </dd></dl>

</div>
</div>
<a id="ga0b829c53e35427a848218f0e6299a7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b829c53e35427a848218f0e6299a7b8">&#9670;&nbsp;</a></span>M_conf_get_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a>* M_conf_get_sections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a list of the section in the ini file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of sections. </dd></dl>

</div>
</div>
<a id="ga814d49e7dbc25454640c074022158f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814d49e7dbc25454640c074022158f09">&#9670;&nbsp;</a></span>M_conf_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* M_conf_get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value for the provided key in the ini file. If a single key is allowed to have multiple values, then this returns the first value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value for the key. </dd></dl>

</div>
</div>
<a id="gaf6f24ddb7acc5bee3b085dfb24059867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f24ddb7acc5bee3b085dfb24059867">&#9670;&nbsp;</a></span>M_conf_get_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__list__str.html#ga6de38b5604cb0dee336dccb52b5ae077">M_list_str_t</a>* M_conf_get_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the values for the provided key in the ini file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>The M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of values for the key. </dd></dl>

</div>
</div>
<a id="ga6cd07cbbd816c34115ca81d12f7de1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cd07cbbd816c34115ca81d12f7de1c9">&#9670;&nbsp;</a></span>M_conf_register_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga8aaf2ce073cfabc0f1a29ef59910291c">M_conf_converter_buf_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored in the provided char buf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. Pass NULL for no default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regex</td><td>Regular expression to check the value against. Matching is done in a case-insensitive fashion. If the check fails, then <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> will also fail and the default value will be stored. Pass NULL to skip check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gaa89b6e9542fc4235b18195ebaec9ceed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89b6e9542fc4235b18195ebaec9ceed">&#9670;&nbsp;</a></span>M_conf_register_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaf10ab3307d18e462d7b9281cd2aa0e96">M_conf_converter_strdup_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as an allocated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address</td><td>Address where the value will be stored. The caller is responsible for free'ing this memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. Pass NULL for no default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regex</td><td>Regular expression to check the value against. Matching is done in a case-insensitive fashion. If the check fails, then <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> will also fail and the default value will be stored. Pass NULL to skip check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gadccb09046cfa4d67fb964f5e3059ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccb09046cfa4d67fb964f5e3059ae46">&#9670;&nbsp;</a></span>M_conf_register_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_int8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int8 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int8&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int8&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int8&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga5abfe9d879ab797ee435b6792e3cdbdd">M_conf_converter_int8_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as a signed 8-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gadcc652c7aebc38f30dcf2e5863bd19a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc652c7aebc38f30dcf2e5863bd19a1">&#9670;&nbsp;</a></span>M_conf_register_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_int16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int16 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int16&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int16&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int16&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gae7bb6781a51c1f461fd60e76bf66ab05">M_conf_converter_int16_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as a signed 16-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga0f2d49bd3dff578fb815c2b639d23575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f2d49bd3dff578fb815c2b639d23575">&#9670;&nbsp;</a></span>M_conf_register_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int32 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int32&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int32&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int32&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga29ddc88da9bdb5b59578557275b3aff6">M_conf_converter_int32_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as a signed 32-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga9c61e4fbd9c21738531ff2abb8c3fba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c61e4fbd9c21738531ff2abb8c3fba3">&#9670;&nbsp;</a></span>M_conf_register_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_int64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int64 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int64&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int64&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int64&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gafacab63cc6af22efe6689d5654f609f2">M_conf_converter_int64_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as a signed 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga1f3b1f30ee320c029bf9a33aa9c18087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f3b1f30ee320c029bf9a33aa9c18087">&#9670;&nbsp;</a></span>M_conf_register_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_uint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaf1039216960ecc6d73dd46506673c881">M_conf_converter_uint8_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as an unsigned 8-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gac103c0f9c851a2910ded2b38ecb09c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac103c0f9c851a2910ded2b38ecb09c93">&#9670;&nbsp;</a></span>M_conf_register_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_uint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint16 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint16&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint16&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint16&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga1423b3fdb407a13b73cead9c6ba472b9">M_conf_converter_uint16_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as an unsigned 16-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga87bac8cf215e7d36d30778d1779da445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87bac8cf215e7d36d30778d1779da445">&#9670;&nbsp;</a></span>M_conf_register_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_uint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gadb85624cc442513413775db1517b2b07">M_conf_converter_uint32_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as an unsigned 32-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gae686e07d650501b0c758a5d122255741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae686e07d650501b0c758a5d122255741">&#9670;&nbsp;</a></span>M_conf_register_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_uint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64 *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga1b162c6e0030211040b009240f8d674a">M_conf_converter_uint64_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as an unsigned 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gac5caba7a59d2b7659c1d9b048ab286a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5caba7a59d2b7659c1d9b048ab286a0">&#9670;&nbsp;</a></span>M_conf_register_sizet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_sizet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga02bf8f8a26d939795d1e9067187e31f7">M_conf_converter_sizet_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value stored at the provided address as a size_t integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>Minimum allowed value. A value in the ini file less than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>Maximum allowed value. A value in the ini file greater than this will cause <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> to fail and the default value to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="gab82b6b62dfff857de71d6ccee41bea90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab82b6b62dfff857de71d6ccee41bea90">&#9670;&nbsp;</a></span>M_conf_register_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>default_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga56af410e1358e4dff55166cef25b4488">M_conf_converter_bool_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value parsed for boolean truthfulness and stored at the provided address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_val</td><td>Default value to store, if a value is not set in the ini file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. Pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga455b51d65b197be16cf9913eee3531fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455b51d65b197be16cf9913eee3531fb">&#9670;&nbsp;</a></span>M_conf_register_custom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_custom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga64ccc6447638ce8b3ba955879ef630b8">M_conf_converter_custom_t</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a key that will have its value manually validated and converted. This passes the value straight to the converter callback and does not do any validation or conversion internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to register. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>Memory where the value will be stored. Pass NULL if not needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">converter</td><td>Callback for manual conversion. The value will be pulled out of the ini and passed directly to the callback, which must do all validation/conversion. The value passed to the callback can be NULL. This must be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if any of the arguments are invalid. </dd></dl>

</div>
</div>
<a id="ga5539dfa70f44ee372f26799d1c33ab93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5539dfa70f44ee372f26799d1c33ab93">&#9670;&nbsp;</a></span>M_conf_register_validator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_conf_register_validator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#gaac290bc7c633860d3490e40253c071d6">M_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__conf.html#ga646da551f1482e6c8a3630409d88d593">M_conf_validator_t</a>&#160;</td>
          <td class="paramname"><em>validator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a validation callback. All registered validators are called after <a class="el" href="group__m__conf.html#ga0faef10ccb592c627b1bca42207dbe63">M_conf_parse()</a> sets the registered keys. This can be used, for example, if you want to validate that one key's value is greater than another key's value, or if you want to print a debug statement for a certain key or keys. This can also be used to run a hook after the registrations are set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>M_conf_t object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validator</td><td>Callback for validating stored values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Reference for passing in data in the callback. May be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the registration was successful. Otherwise, M_FALSE. Currently, this returns M_FALSE only if the callback is invalid. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 21 2022 20:22:19 for Mstdlib-1.18.0 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
